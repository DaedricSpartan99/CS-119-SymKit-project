\documentclass{report}

\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage[T1]{fontenc}

\usepackage{listings}
\usepackage{color}

\selectlanguage{francais}


\definecolor{dkgreen}{rgb}{0,0.6,0}                                             
\definecolor{gray}{rgb}{0.5,0.5,0.5}                                            
\definecolor{cleargray}{rgb}{0.95, 0.95, 0.95}                                  
\definecolor{mauve}{rgb}{0.58,0,0.82}                                           

\lstset{
    frame=tb,                                                               
    backgroundcolor=\color{cleargray},                                            
    language=C++,                                                                
    aboveskip=3mm,                                                                
    belowskip=3mm,                                                                
    showstringspaces=false,                                                       
    columns=flexible,                                                             
    basicstyle={\small\ttfamily},                                                 
    numbers=left,                                                                 
    numberstyle=\tiny\color{gray},                                                
    keywordstyle=\color{blue},                                                    
    commentstyle=\color{dkgreen},                                                 
    stringstyle=\color{mauve},                                                    
    breaklines=true,                                                              
    breakatwhitespace=true,                                                       
    tabsize=3                                                                     
}            

\title{Symkit, du projet}
\author{Ancarola Raffaele et Cincotti Armando}

\begin{document}

\maketitle

\tableofcontents

\begin{abstract}

Dans le cadre du cours d'informatique de la section de Physique, pour l'année 2018 on se trouve à devoir développer
un programme permettant de simuler numeriquement, et visualiser graphiquement, un sistème de plusieurs oscillateur harmoniques
et d'oscillateurs couplés.
Le document qui suit sert à illustrer la conceptualisation de notre projet couche par couche, jusqu'à l'illustration complète
de ce qu'est notre programme à l'heure actuelle et de ses fonctionnalités.
Dans l'idéation du programme, tout en suivant les cosignes principales, nous avons essayé de garder nos idées originales,
pour rendre notre travail plus personnel possible, en deviant parfois dès consignes secondaires données par le professeurs
tout le long de l'année pour nous guider dans la création du programme.
Dans la suite, on essayera d'expliquer au mieux quand est-ce que notre programme devie dès consignes données, et pourquoi.
Deux sont les buts que nous nous sommes donnés dans le developpement du projet:
Le principal étant la bonne réusite de notre travail dans le cadre du cours, et donc dans le but d'obtenir une bonne évaluation.
Le deuxième, pas moins important pour nous, étant la création d'un util numérique pour simulations physiques plus générales,
étant donné qu'un tel programme pourrait nous être très utile tout au long de notre formation de physiciens.

Le projet principal, qu'on a appelé Symkit (pour Symulation Kit), est composé de quatre sous-parties, qui gèrent les aspects purement 
matématiques, graphiques ou du plotting de graphes liés aux systèmes physiques simulés, et finalement l'implementation d'une interface utilisateur.
Symkit compte en plus deux subdirs Alpha et Beta, qui font le lien entres les trois partie du programme. 
Ils contiennent en faite le main qui crée et lance les simulations numeriques et leurs raprèsentations graphiques.
Alpha comprenant nos premiers tests sur le complexe du programme, et Beta representant le résultat final après toute correction et 
amélioration.

\end{abstract}

\chapter{Symath}

\section{Vectors}

Liste des classes:

\begin{itemize}
\item \textbf{Vector}
\item \textbf{SVector}\detokenize{<std::size_t N>}
\end{itemize}

\subsection{Vector}

Cette classe raprèsente un vecteur à dimension quelquonque, utile pour la gestion d'un ou plusieurs paramètre.
La dimension dépend souvent du nombre de degrès de liberté de l'oscillateur où le vecteur est utilisé. Par exemple
pour un pendule qui bouje le long d'un plan fixe dont on peut modéliser le mouvement en fonction de la seule variation
d'un angle, on utilisera un Vector de dimension 1 ayant en cordonnée l'angle que le pendule crée avec la verticale. 
\par
Pour cette classe sont definis: 
\begin{itemize}
\item Un constructeur par defaut l'initialisant à la valeur {0}, un \textbf{Vector} par defaut sera donc de dimension 1
   ceci parce que les oscillateurs harmoniques décrits ont souvent un seul degré de liberté.
\item Des constructeur pour initialiser un \textbf{Vector} de plusieurs manières (par vector, initializer list etc.).
\item Des utils de looping pour traverser les differents paramètre (utilisés parfois dans les autres fonctions implementées).
\item Fonctions pour la modification de la \textit{dimension du Vector}.
\item Plusieurs operateurs dont:
    \begin{itemize}
	\item Un accesseur aux paramètre stockés, \textit{operator}[], permettant aussi de les modifiers s'il le faut.	
	\item Des operateurs implementant somme interne et produit externe canoniques d'un espace vectoriel R(n). Ces ci sont construit pour permettre la concatenation d'operations sur des Vector.
	\item Operateur implementant produit scalaire et vectoriel (si la dimension des Vector est compatible, sinon on lance un erreur).
	\item Des operateurs de comparaison d'ordre, qui effectue la comparaison sur le module du/des Vector.
	\item Des operateurs de comparaison de similitude, pour savoir si deux Vector sont égaux ou non.
	\item Un operateur "-" retournant l'inverse additif du Vector, et "\detokenize{~}" l'inversant.
    \end{itemize}
\item Deux fonction retournant le module du vecteur ou son carré (pour éviter une operation de plus).
\item Une fonction returnant le vecteur unitaire du Vector concerné. Cette fonction est très utile pour caractériser des axes de restriction de mouvement.
   En effet, pour evaluer la projection d'un vecteur sur un certain axe de mouvement, pour simplifier les calculs il suffit de calculer le produit scalaire
   du vecteur pour le vecteur unitaire décrivant l'axe.
\end{itemize}

\subsection{SVector}

Celle-ci est une classe qui n'a pas été demandé par le prof, mais qu'on a crée pour distinguer les vecteurs pour la gestion de paramètres numériques caractérisant
les systèmes physiques simulés, dès vecteurs utilisés pour placer des objet dans un environnement graphique tridimensionnel.
\textbf{SVector} est une \textit{classe template}, pour qu'on puisse la definir pour différentes valeurs de T. T representant une dimension fixe pour un SVector.
Cette classe décrit donc des vecteurs à dimension fixe, et elle implemente essensiellement les même fonctions présentes dans la classe Vector sauf pour celles qui en modifient la dimension.
En effet, des vecteurs destinés à "se déplacer" dans un espace à dimension finie fixe, n'auront jamais à modifier leur dimesion.
Cette classe a été créée pour être utilisé dans la partie du programme qui gère la graphique. 
Des \textbf{SVector<3>} (de dimension 3) sont donc utilisés plus loin dans le programme pour décrire par exemple la position de caméra et objets graphiques.
\\
Pour les deux types de Vecteurs a été défini en fin, un overload de l'\textit{operator<<} pour qu'on puisse afficher facilement la liste de valeurs d'un vecteur.
Cet operateur est utilisé par exemple pour afficher les valeurs de position et vitesse d'un objet physique en évolution, pour obtenir ainsi une simulation en mode texte.
\\
N.B. Un objet graphique est placé dans l'environnement 3D en fonction d'un \textit{SVector<3>}, mais l'objet physique lié à un certain objet graphique,
est décrit au travers d'un \textit{Vector} contenant sa vitesse et un Vector contenant sa position, lesquels peuvent évoluer en fonction d'équations spécifiés plus loins dans le programme.
Il y pourtant l'ecception des objets physiques décrit par des \textbf{NewtonDescriptors} (voir paragraphe suivant), lequels sont décrit au travers de \textit{SVectors<3>}.

\section{Descriptors}

Un \textbf{Descriptor} est un objet qui permet de décrire un comportement évolutif dans le temps pour un objet physique quelquonque.
La classe \textbf{Descriptor} est une classe abstraite, contenant en effet une unique méthode virtuelle pure \textit{update()}, utilisée pour "mettre à jour" l'objet,
en le faisant évoluer en fonction de son type (oscillateur ou masse ponctuelle newtonienne pour ce qui a été fait à l'heure actuelle).
Cette méthode est donc redefinie dans les classes héritant Desciptor.


Voici des specifications pre-définies de cette classe:

\begin{itemize}
\item \textbf{NewtonDescriptor}: décrit un objet dans un éspace tridimensionnel
\item \textbf{Oscillateur}: décrit l'évolution d'un oscillateur
\end{itemize}

\subsection{Oscillateur}

Un \textbf{Oscillateur} est un descriptor décrivant le mouvement d'un oscillateur harmonique ou d'un oscillateur couplé.
Celle-ci est une classe abstraite.
Attributs:
\begin{itemize}
\item Deux Vectors contenant \textit{positions} et \textit{vitesses} des masses composantes l'oscillateur décrit.
	  Ceux-ci peuvent être modifiés pour que l'objet décrit puisse évoluer.
\item Un \textbf{integral\_operation} qui est un type enum (EULER\_CROMER ou NEWMARK) qui sert à spécifier au travers de quel intrgrateur
	  la méthode \textit{update()} mettra à jours les valeurs de position et vitesses de l'oscillateur.
\end{itemize}
Méthodes:
\begin{itemize}
\item \textbf{equation()}, une méthode virtuelle pure qui défini, dans chaque sous-classe d'oscillateur, l'équation décrivant le mouvement de l'oscillateur.
\item \textbf{update()}, redefinie ici pour prendre en argument un pas de temps et modifier avec un certain \textit{integrateur}, les valeurs de vitesse et position
	   de l'osccilateur. Ceci est fait en fonction de la methode \textit{equation()}.
	   Le comment la methode equation est utilisée est spécifié lors de l'explication des integrateurs.
\item Des constructeurs appropriés, exploitant chaqu'une manière différente de construir un Vector.
\item Accesseurs et Manipulateurs pour accèder ou modifier les attributs de la classe.
\end{itemize}

\subsection{OscillateurSimple}
Sous-classe abstraite d'Oscillateur décrivant les oscillateurs comportant une seule masse.
Cette sous-classe ajoute à la classe Oscillateur une méthode virtuelle pure \textbf{cartesiennes()}.
Cette dernière a été implementée pour convertir la position de la masse décrite en un \textit{SVector<3>}.
En utilisant des cordonnées cartesiennes dans l'environnement graphique, on en a besoin pour qu'on 
puisse utiliser un vecteur position compatible avec l'implementation graphique.
Vu qu'un \textbf{OscillateurSimple} décrit le mouvement d'une seule masse, ça vaut la peine, d'après nous, d'accèder ainsi à la position de l'objet.

\subsection{NewtonDescriptor}
Un \textbf{NewtonDescriptor} est un descriptor décrivant l'évolution d'une masse pontuelle sujette à des forces, dans un espace euclidian
suivant les principes de la mécanique newtonienne.
Attributs:
\begin{itemize}
\item Masse de l'objet.
\item Trois SVector<3>, contenant \textit{position}, \textit{vitesse} et \textit{forces} appliquée à l'objet.
\end{itemize}
Méthodes:
\begin{itemize}
\item Constructeurs appropriés et un destructeur.
\item \textbf{update()}, qui modifie position et vitesse de l'objets par l'integrateur d'\textit{Euler Cromer}, en foncion du vecteur force resultant appliquée à l'objet
     et en fonction de sa masse.
\end{itemize}

Il nous parait important de spécifier que la classe \textbf{NetonDescriptor} n'as pas étée demandée pour le projet, et que restent des corrections à faire
vu qu'on s'est intéressés plus à ce qui était démandé, pour bien réussir dans notre évaluation finale.
On a quand même crée un tel objet dans le main pour en illustrer l'idée d'implementation possible.
Pour un \textbf{Oscillateur} a été implementé un overload de l'\textit{operator<<}, permettant d'imprimer sur un ostream comme cout, les vecteurs position et vitesse.
Cet affichage, à chaque pas de temps, sera l'implentation pour une simulation en mode texte.


\section{Integrateurs}

\begin{itemize}
\item Vector \textbf{integrateEulerCromer}\detokenize{<typename>}
\item Vector \textbf{integrateNewmark}\detokenize{<typename, class Owner>}
\end{itemize}

Celle des integrateurs est une des implementations qui a le plus dévié par rapport aux indications donnés.
Les indications voulaient qu'on crée une classe integrateur qui traite la méthode d'integration d'un oscillateur différemment
en fonction du type d'integrateur pris, et que ce soit l'integrateur à prendre en attribut un oscillateur pour le modifier.
Dans notre conception, à chaque méthode d'integration correspond une \textit{fonction} qui prend en paramètre(par référence), un vecteur position et vitesse
et en modifie les valeurs en fonction d'un pas de temps et d'un vecteur acceleration.
Ce dernier correspond à la valeur de retour de la fonction \textbf{equation()} pour les oscillateurs, et au vecteur forces pour un NewtonDescriptor.
C'est donc, le \textbf{Desciptor} qui appele la méthode d'intégration choisi au travers de la méthode \textbf{update()}, en modifiant ainsi ses propres attributs de vitesse et position.
Les méthodes d'integration sont insérées dans \textbf{integrator.h} (et .tpp), dans le \textbf{namespace symkit}, ainsi les \textbf{Descriptors} y ont accès au travers de ces deux ligne de code: 
\textit{"\#include skerror.h"}
\textit{"using namespace symkit"} (pour faciliter l'appel des méthodes).
De plus les méthodes sont définies pour un type \textbf{template}, pour qu'elle puissent fonctionner pour des \textit{Vectors}, si les appelle un Oscillateur,
ou aussi pour des \textit{SVectors}, si à les appeler est un NewtonDescriptor.
Grace à cette implementation, on évite de créer une classe de plus à chaque fois qu'on veut implementer une nouvelle méthode d'integration.


\section{Symkit Error, géstion des érreures}

\textbf{SKerror} est une structure contenant données, informations et commentaires utiles pour gérer un erreur pendant l'éxecution du programme.
Se trouvant dans \textbf{namespace symkit}, à l'interieur de \textbf{skerror.h}, toutes les classes peuvent y avoir accès, et l'utiliser facilement
à travers les commande \textit{"\#include "skerror.h""} et \textit{"using namespace symkit"}.
Lorsque, dans une certaine fonction le code est suceptible de générer une erreur, un \textbf{SKerror} est lancé, et au moment du catch
un message d'erreur est affiché sur l'ostream cerr, grace à l'overload de l'\textit{operator<<} pour les \textbf{SKerror}.
Eventuellement le programme s'arrête si l'erreur est fatale.
Les informations contenues dans un SKerror sont:
\begin{itemize}
\item Type d'erreur (de type enum).
\item Nom de la fonction qu'a généré l'erreur.
\item Nom de la classe qui contient cette fonction.
\item Fatalité ou non de l'erreur (de type bool).
\end{itemize}

\chapter{Symgraph}

\section {Scene}

La classe \textbf{Scene} ouvre une fenêtre \textit{OpenGL} et manage le monde de dessin 3D.
Elle implémente un mécanisme qui enregistre les composantes de type \textbf{SKActor} et les distingue parmi leur rôle (évoluable, dessinable, etc).
Les rôles seront spécifiés dans les prochaines section. 
C'est dans cette classe qu'on gére le \textit{fonctionnement/evolution} des objets graphiques, ajoutés à la scène, en temps de compilation,
et en runtime, grace au système des \textbf{listeners} qui traduisent des input clavier (et eventuellement souris, à implementer), en commandes de gestion en temps réel.
La scene peut hériter d'une classe listener, si elle gère les input d'un certain type.
\textbf{Scene} implémente une fonction pour la gestion de la runtime (voir \textbf{Scene::timerEvent} en \textbf{symgraph/scene.cpp})
laquelle définie l'ordre de mise à jour des éléments travaillant dans et sur la scène, ordre à respecter à chaque pas de temps, en tenant compte des input externes, si il y en a.
Le \textit{pas de temps} est propre à la scène, comme si les objets se trouvaient dans un espace avec un temps rélatif identique pour toutes les particules (ce qui est sensé d'après nous).
\textbf{Scene} est strictement liée à une classe \textbf{Camera} pour la gestion de la vision du monde 3D de symulation.
\textbf{Scene} gère aussi la simulation mode texte: si l'on veut, en appuyant sur un numero il est possible d'afficher les valeurs d'évolution d'une ou plusiseures particules.
Ainsi faisant la simulation mode texte devient optionnelle, mais elle est de toute façon implementée.
\\
\\
Cette classe est celle qui correspond, à peu-prè, au support à dessind demandé par les consignes du projets. 
Pourtant nous l'avons implementée comme étant une scène, prenant des objets graphiques, bien différents des Descriptors mais liées à ceux-la pour évoluer dans la scène.
Scene est un \textbf{SceneWrapper} (Classe décrite plus loin) donc elle contient plusieurs objets graphiques, des actors, qu'elle fait évoluer et qu'elle dessine chaqu'un de sa manière
grace au mécanisme de résolution dynamique des liens.
Donc, comme pour un support à dessin elle gère le dessin, mais la méthode de déssin reste propre aux objets déssinnés

\section {Camera}

\textbf{Camera} est une classe qui contient les infomations et les methodes pour la gestion d'une camera virtuelle dans le monde graphique 3D.
La classe \textbf{Scene} peut facilement obtenir de cette classe une \textit{QMatrix4X4} pour la création de la scène 3D au travers de la fonction \textbf{getMatrix()} contenue dans Camera.


\section {Specifics (Specs)}

Les superclasses qui déterminent l'identité d'un objet destiné à être enrégistré dans \textbf{Scene} sont à la base du système polimorphique de \textit{Symgraph}.
En faite, chaque classe joue un rôle différent, par une ou deux méthodes, dans le déroulement d'un \textit{frame} pendant la simulation.
Voici les classes en ordre d'appel :

\begin{enumerate}
\item \textbf{Evolvable} : Classe des objets graphiques pouvant \textit{évoluer}, elle contient une fonction d'évolution \textit{evolve(float)}.
\item \textbf{Describable} : Classe des objet pouvant \textit{évoluer} selon un \textit{Desciptor}, elle contient donc une reference au descriptor du quel cette classe dépend.
\item \textbf{Positionnable} : Classe des objets peuvant être \textit{positionnés}.
\item \textbf{Orietable} : Classe permettant d'appliquer une \textit{orientation} à l'objet.
\item \textbf{Scalable} : Classe permettant de changer la \textit{grandeur} des objets graphiques.
\item \textbf{Colorable} : Classe permettant de changer la \textit{couleur} des objets graphiques.
\item \textbf{Renderable} : Classe des objets \textit{déssinables}.
\end{enumerate}

De plus, pour permettre de pouvoir abiliter/désabiliter ces fonctions pour une certaine classe qui hérite ces caractéristiques, dans le fichier \textit{specs.h} est définit un
système à \textit{bitfield} qui manage cette option.
\\
 \textbf{N.B.}
 Ces Specifics s'appliquent à des objets graphiques, comme par exemples des particules (voir plus bas), on ne déssinne donc pas dans des oscillateur dans la scène,
 mais plutôt des particules liées aux oscillateurs, étant ces derniers des objets physiques décrivant, dans notre conception, l'évolution d'une particule ou d'un système de particules.

\subsection{Quelques mots de plus sur Specs.h}

Si on regarde le contenu du fichier, on voie qu'il n'y a que de définitions de
macro. En particulier, la classe \textbf{SKActor} construit son mécanisme de
management des \textit{flags} par l'utilisation de cette dernières.
\par
\par
L'idée qui est derrière est celle, pour chache acteur, de pouvoir manager ce qui 
est active e ce qui ne l'est pas en n'utilisant qu'un \textit{byte} de mémoire.
Puisque les identités specs sont exactement 8, alors on a exactement 1 bit
réservé à chaque identité, pour à la fin composer un nombre de type
\textit{unsigned char}, c'est à dire un byte.
La définition des bits resérvés est la suivante:

\lstinputlisting{res/specsbit.h}

Pour comprendre comment ce système est interfacé dans les acteurs, il faut d'abord
considérer que la variable qui contient les flags est définite à l'interieure de
la classe \textbf{SKActor}, elle a un nom fixe et son accéssibilité est
\textit{protected}. Pour \textit{nom fixe}, on entend qu'il y a aussi une macro qui
définit son nom. On va voir que les définitions de specs.h ne se limitent pas à
la déclaration de la \textit{bit map} ou de la variable de stockage, mais aussi 
de l'accès à ce mécanisme pour garantir de l'agréabilité en l'utilisant.
\par
On peut, à ce point là, regarder la définition de \textbf{SKActor}:

\lstinputlisting{res/skactorspecs.h}

La macro \textbf{SPECS\_FIELD} s'expande directement dans la définition de 
la variable de stockage de la bit map, où son nom est forcement donnés par
\textbf{SPECS\_VAR}:

\lstinputlisting{res/specsfield.h}

D'autre côté, la macro \textbf{SPECS\_ACCESS} engendre les accésseurs minimalistes à cette
variable, qui permettent la convérsion entre des booleans et des
\textit{specs\_t} et qui permettent aussi de l'affecter entièrement.

\lstinputlisting{res/specsaccess.h}

Ici, on voie la raison pour laquelle le nom de la variable de stockage est fixe:
pour que elle soit utilisable dans les autres macro et les implémentations se
réfèrent toujours à elle, son nom doit forcement être constant.
Même si les méthodes générés par les macro specs marchent sous ces conditions
strictes, l'utilisateur ne va jamais percevoir des difficulté. En fait, ce
mécanisme est strictement limité à la costruction de la classe \textbf{SKActor}
et on va voir comment peut-on en beneficier par héritage.

\subsubsection{Application à une classe Specs}

Potentiellement, toute classe peut hériter d'une classe specs, mais, 
par construction, chaque classe specs ne possède aucune géstion de l'activation 
ou de la déactivation sa propre fonctionnalité.
Prendons par exemple \textbf{Evolvable}:

\lstinputlisting{res/evolvable.h}

La peculiarité de cette classe est de posseder la méthode \textit{evolve}, qui 
peut être définite dans plusieurs façons. Ce qui nous intéresse est le fait que,
quand la scene essaye de faire appèl à cette méthode, elle execute d'abord un
control supplémentaire; c'est ici que la méthode \textit{isEvolving} est
appellée et elle retourne le status d'actif ou inactif.
Mais, en fait, cette méthode est virtuelle pure et il faut toujours le définir
dans les sous-classes; c'est ici qui le mécanisme de management des specs flags 
entre en jeu. 
Quand un acteur hérite une classe specs comme \textbf{Evolvable}, on ajoute
aussi (dans la séction \textit{public}) la macro \textbf{SPECS\_EVOLVE}.

\lstinputlisting{res/specsapp.h}

Cette macro engendre les méthodes manipulateurs de la variable de stockage specs 
qui a été héritée par \textbf{SKActor}. En fait ces manipulateurs agissent
directement sur la variable, qui est d'accès \textit{protected}, il est donc 
nécéssaire hériter la classe SKActor pour pouvoir utiliser ce mécanisme correctement.
Compris entre ces méthodes, il y a la définition de \textit{isEvolving}. 
Le rôle de cette macro, est donc aussi celui de définir la méthode virtuelle 
qui avait été déclarée dans la superclasse \textbf{Evolvable}.
\par
\par
On peut, toute de suite, regarder la définition des manipulateurs:

\lstinputlisting{res/specsabstractmethod.h}

Qui va se concrétiser dans les \textit{SPECS} macro:

\lstinputlisting{res/specsmethods.h}

\section{SceneWrapper}
 
\textbf{SceneWrapper} est la super classe d'un objet de classe \textbf{Scene}. 
Cette classe contient 4 liste de pointeurs à 4 types d'objets graphiques differents:
\begin{itemize}
\item \textbf{SkActor}
\item \textbf{Evolvable}
\item \textbf{Describable}
\item \textbf{Renderable}
\end{itemize}
Ainsi une instance de scene pourra travailler sur ces 4 types différents d'objets spécifiquement.
\textbf{SceneWrapper} hérite directement de \textbf{Evolvable} et de \textbf{Renderable}, donc elle contient une méthode \textit{evolve()} et \textit{render()}, qui consiste à faire évoluer et déssinner
les \textit{renderables} et \textit{dessinnables} qu'elle gère, simplement grace au mécanisme de la résolution dynamique des liens, en appelant \textit{evolve()} et \textit{render()} pour chaqu'un des objets.
Il est vrai que des objets contenus comme les evolvables et describalbe peuvent être les deux en même temps, mais en enregistrant leurs adresses dans des listes différentes
lorsqu'on veut dessinner tout les dessinnables, ou utilisers tout les actors, ou plus, il suffit d'appeler la fonction pour les membre d'une des liste, ainsi on gagne en complexité temporelle
car pour des objet qui sont forcement tous spécialisés dans l'action qu'on demande, il n'y a pas besoin de faire tout un tas de contrôles néccessaires autrement.
 
 
\section {Symkit Actors}

La classe \textbf{SKActor} est la classe base de tout ce qu'on peut 
enregistrer dans une \textbf{Scene}. 
Chaque instance de cette classe contiendra une \textit{Qstring} fonctionnant de ID, et un \textit{bitfield} permettant d'activer ou desactiver,
à l'initialisation de l'acteur, ses spécificités (comme décrit dans \textit{specs.h}). 
La classe se refère à \textit{specs.h} pour obtenir les variable et méthodes nécessaires pour le fonctionnement à bitfield du système de specifics (voir commentaires dans \textit{specs.h}).
\\
Les sous-classes définies dans symgraph se divisent dans les suivantes catégories :
\begin{itemize}

\item Formes (Shape)

\begin{itemize}
\item Décorations
\item Particules
\end{itemize}

\item Systèmes (ParticleSystem)

\begin{itemize}
\item Systèmes interactifs
\item SySystèmes d'oscillateurs
\end{itemize}

\end{itemize}

\subsection{Formes et décorations}

La classe \textbf{Shape} hérite \textbf{SKActor}, \textbf{Renderable} et 
\textbf{Colorable}. Son but est de dessiner un \textit{modèle graphique}.
Précisement elle contient une référence à un \textit{modèle graphique} 
qui va être utilisée pendant l'ésecution de \textit{render}.
Il faut donc toujours donner une référence d'un modèle à une instance de
\textit{Shape}, sinon il va rien dessiner.


En particulier, cette classe est à la base de \textbf{Decoration}, 
dont l'objectif est de dessiner un modèle en donnant une position,
une orientation et une rapport de volume dans l'espace tri-dimensionnel, 
sans avoir aucun comportement evolutif.
L'autre spécialization pré-définie de \textbf{Shape} concèrne les
formes qui vont avoir un comportement évolutive et qui sont aussi
déstinées à simuler de la physique, on parle de la classe \textbf{Particle}.

\subsection{Particules et oscillateurs}

Maintenant, on arrive à interfacer la physique au graphisme.
En faite, la classe fille de \textbf{Shape} qui s'occupe de cet but est 
la classe \textbf{Particle}, qui n'est rien d'autre qu'une forme 
qui hérite \textbf{Descriptor} et \textbf{Positionable}. Noter que dans 
cette classe rien est encore défini parce qu'elle est abstraite.
Les deux spécifications de cette classe sont \textbf{NewtonParticle} et 
\textbf{OscillatorParticle}. La différence principale entre les deux est 
le type de \textbf{Descriptor} qu'elles utilisent, en fait, la première 
contient une \textbf{NewtonDescriptor} et la deuxième un \textbf{Oscillateur}.
Les deux définissent les méthodes virtuelles de la superclasse en fonction de la
nature du \textbf{Descriptor} et, de plus, elles ajoutent des accesseurs et des 
modificateurs selon le besoin.
En particulier les deux classes contiennent une méthode \textit{position()} qui permet d'obtenir la position évoluante pour dessinner le model dans le monde graphique.
On a fournit de plus à la classe \textbf{OscillatorParticle}, un offset et des méthodes permettant de deplacer l'origine autour de la quelle la particule évolue.

\subsection{Systèmes de particules}

Pour ce type d'objet existent dans notre programme plusieures implementations, dont certaines implementées pour être utilisées en dehors du cadre du projets, et pour élargir le domaine de simulations possibles de notre programme.
 
\subsubsection{Particlesystem}
\textbf{ParticleSystem} est une classe qui gère plusieurs \textbf{Particles} permettant de les regrouper dans un domaine.
Elle possède donc une liste de pointeurs à des particules, et des méthodes pour en ajouter ou en enlever.
Cette classe hérite de \textbf{Evolvable} et \textbf{Renderable} et définit donc les méthodes pour faire évoluer et déssinner les particules stockés dans cette classe.
Un \textbf{ParticleSystem} possède aussi un offset, et hérite de \textbf{Positionnable} la méthode \textit{position()} qui retourne ce dernier paramètre, pour qu'on puisse déssinner
chaque particule en fonction de la position du système. Chaque particule évoluera autour de l'offset du système.

\subsubsection{InteractingSystem}

\textbf{InteractingSystem} hérite de \textbf{ParticleSystem} et spécifie comment les particules du système interagissent entre elles à deux à deux par la méthode \textit{interaction(Particle *, Particle *)}.
Cette classe a été conçue pour faire évoluer des Particules de type \textbf{NewtonParticle}, elle sort donc du cadre du projet, mais elle nous sera utile en futur, pour permettre
de developper des interaction physiques plus générales entre particules.
Elle redefinie la méthode \textit{evolve()} pour considérer l'interaction entre particules.

\subsubsection{Système Pendule-Couplé}

Une classe \textbf{ActorGroup} hérite directement de \textbf{SceneWrapper} et sert comme classe de base pour un système de type \textit{pendule-couplé}.
Un tel système est representé par la classe \textbf{SymSystem}, qui hérite entre autre de \textbf{Describable} et \textbf{Positionable} (pour implementer le même système d'offset que le Particlesystem).
Il prend comme descriptor des \textit{Descriptor} pour oscillateurs couplés, pour obtenir de ce dernier les informations pour dessinner et faire évoluer deux particules.
Dans le subdir \textit{Beta}, pour finir, pour chaque sous-classe de \textbf{Symsystem} sera définie une \textit{Shape positionnable}, qui prend en attribut un numero d'identification (0 ou 1 pour deux oscillateurs couplés entre eux)
et qui retourne, par la méthode \textit{position()} la position de la shape en fonction de son id.
	\\
	\\
	Pour simplifier la compréhénsion du fonctionnement de la classe, de suite un exemple détaillé est illustré.
	\\
	Ex.\\ Dans \textit{Beta} existe la classe \textit{PendCouple}, qui hérite de \textit{SymSystem}, et \textit{PenduleDesc} qui est un Descriptor de type \textit{Oscillateur} décrivant l'évolution d'une couple de pendules. 
		On defini maintenant une Shape \textit{PendSphere}, qui hérite de \textit{Positionnable}. PendSphere prend en attribut un \textit{pointeur à un PenduleDesc}, et un int constant fonctionnant de numero d'\textit{identification}.
		Si le id est 0, la méthode \textit{position()} retourne la position de la première particule décrite par PenduleDesc, sinon elle retourne la position de la deuxième particule décrite.
		\textit{PendCouple} prend en attribut un \textit{pointeur à PenduleDesc}, et \textit{deux pointeurs à deux PendSphere} initialisées avec 0 et 1 comme id.
		PendCouple initialise les PendSphere auquel ses pointeurs pointent, en leur donnant en réference PenduleDesc, ainsi il pourra les dessinner chacune en fonction de leur position.

\section {Modèles graphiques}

On a dit plus haut qu'une forme prends une référence à un modèle de dessin et 
pendant l'appel de \textit{render} elle le dessine. Précisement, 
derrière à la concéption de modèle, il y a les appèls à la \textit{OpenGL}.
\\
La classe \textbf{SKModel} est définie par un \textit{Vertex Buffer Object} et 
un \textit{Index Buffer Object}. Les deux sont des conténiteurs de donnés statiquement 
insérés, qui une fois passés à la mémoire, ils restent en modalité de lecture 
jusqu'à quand on ait dit de les libérer. Ce mécanisme permet d'optimiser les appèls du 
procésseur en gagnant aussi beaucoup sur le temps de dessin.
\\
La \textit{Vertex Buffer Object}, en particulier, contient les coordonnés des
vertex en format de groups de trois \textit{float}, le \textit{Index Buffer
Object} contient les références en format de nombres entiérs de où trouver les 
vertex et avec quel ordre les positionner.

\section {Clavier et souris}

\textbf{KeyListener} et \textbf{MouseListener} sont des classes abstraites décrivant des objets déstinés à récolter des input, respectivement venant du clavier et de la sourie,
pour éxecuter une certaine commande à chaque input prédéfini.
Dans une sous-classe de \textit{Scene}, qui hérite \textbf{KeyListener} ou \textbf{MouseListener}, on définit en effet les commandes à executer sous l'influence d'un certain nombre d'input.
Un \textit{Listener} contient pour finir une méthode pour être activé/desactivé, et une méthodes pour controller s'il est activé ou pas.


\chapter{Symplot}

\section{Données}

\subsection{Plot\_data}

Pour representer des données caractéristiques d'un graphe elle existe la struct template \textbf{plot\_data} dans le programme.
Cette struct prend en attribut un \textit{argument} de type indéfini, qui correspond à la préimage d'un point \textit{image} du graphe.
Un double img en attribut représent cette \textit{image}.
\\
Pour l'\textit{Espace des Phases}, on défini un \textit{"typedef plot\_data<double> Point2D"}, qui represente un point bidimensionnel de l'espace.

\subsection{PlotStream}

\textbf{PlotStream} est une classe \textit{template} representante un stream de \textbf{plot\_data}, une liste de points stoqués pour qu'on puisse les dessinner et les garder sur le dessin du graph de l'Espace des Phases.
En attribut elle prend un \textit{vector<plot\_data>} (Pour le projet on crée un \textbf{PlotStream} de \textbf{Point2D}).
Comme méthode elle implemente des \textit{manipulateurs}, \textit{accesseurs} et \textit{itérateurs} pour travailler sur le stream.
Elle implemente enfin la surcharge de l'\textit{operator<<} pour pouvoir ajouter des \textbf{plot\_data} à la liste contenue en attribut.

\subsection{SKAxis}

\textbf{SKAxys} est une struct contenant les information utiles pour la constructions d'un axe dans un graph: l'\textit{échelle}, l'\textit{offset} et la \textit{couleur}.
Cette struct contient aussi, outre qu'un constructeur, deux méthodes pour en modifier l'offset et l'échelle.

\section{Les Graphes}

\subsection{SKplot}

\textbf{SKPlot} est la classe base pour le dessin de graphes dans le programme. 
Elle prend en attribut :
\begin{itemize}
\item  Un pointeur sur un \textit{QGLShaderProgram} pour le dessin du graph.
\item  Deux \textit{SKAxys} pour le dessin des axes. 
\item  Un boolean qui spécifie si les \textit{ShaderProgram} ont été chargées.
\item  D'autres attribut utiles au dessin du graph par les \textit{Shaders}.
\end{itemize}
Les Méthodes :
\begin{itemize}
\item Un constructeur et un destructeur.
\item \textbf{initializeGL()}, fournie dans le tutoriel pour Qt, laquelle charge et compile les shaders
\item \textbf{PaintData} et \textbf{PaintAxis}, méthodes virtuelles pures, pour le dessin des axes et des points à travers un ShaderProgram fourni en attribut.
\item \textbf{PaintGL}, qui appelle \textit{PaintData} et \textit{PaintAxis}.
\item \textbf{ResizeGL} fournie dans le tutoriel Qt.
\item Accesseurs et Manipulateurs des différents attributs de la classe.
\end{itemize}

\subsection{SKPlot2D}

Dans \textit{skplot2d.h} on défini une struct \textbf{ColoredFuncion}, qui prend en attribut un \textbf{PlotStream<double>} et une couleur.
Une couleur est une liste de 4 float fonctionnants selon le protocole rouge, vert, bleu, alpha, où alpha correspond au facteur de \textit{transparence}.
Cette struct represente les points d'une fonction colorée.
\\
\textbf{SKPlot2D} hérite directement de \textbf{SKPlot}, prend en attribut des \textit{ColoredFunctions}, et définit \textit{PaintData()} pour le dessin et coloriage de ces dernières.
Elle définie aussi une fonction \textit{keyPressEvent()} pour la géstion des input clavier.
Cette classe est l'implementation de l'Espace des Phases 2D.

\chapter{Symviewer}

Cette partie concèrne l'interface grafique dediée à l'utilisateur.
Son utilité est de pouvoir changer les donnés de la symulation et, en fait, 
elle s'interface à \textit{Symath}, \textit{Symgraph} et aussi \textit{Symplot} 
pour obtenir accès aux \textit{descriptors} et à les propriétés des
\textit{acteurs}. 
Cette bibliothèque n'utilise que les instruments de l'interface \textit{Qt}.

\section{Viewer window et Panneax}

La fenêtre principal est charactérisée par un tableau \textbf{QListWidget} des objets présents et,
à droite les panneax \textbf{SKViewerPanel} répresentatifs corréspondants. 
Le mécanisme de \textit{mise à jour} des donnés dans la fenêtre est efféctué par 
l'appel de la fonction virtuelle \textit{updatePanel} de tous les panneaux
ajoutés. Par l'appel de la méthode \textit{updatePanels} on active ce mécanisme 
et on mis à jour par conséquent les panneaux.

\subsection{ActorPanel}

Ce type particulier de panneau permet de menager les variables rélatives
à un \textbf{SKActor}. Il contient un panneau \textbf{SpecsChecker} pour 
contrôler les \textit{specs flags}, d'un tel façon qu'on peut les abiliter ou 
déabiliter manuelment. De plus, si le acteur est un \textbf{Describable} et il 
contient un déscriptor de type \textbf{Oscillateur}, alors il va apparaitre aussi 
un panneau supplémentaire pour pouvoir changer l'intégrateur.

\subsubsection{SpecsChecker}

Quand un acteur est passé comme argument, la méthode \textit{setActor} engendre 
les boutons \textit{check box} en fonction de son identité. Il y aura un bouton 
pour chaque \textit{classe specs} identifiée.

\subsection{SystemPanel}

Cette sous-classe de ActorPanel permet d'impiler plusiers \textbf{ActorPanel} 
et il prend par argument un \textbf{SymSystem}. Les panneaux ajoutés sont gerés
par un \textbf{QTabWidget} qui mostre un seuls à la fois.
Il contient aussi un modificateur de vecteur pour l'\textit{offset} du système.

\subsection{Éspace des phases}

Le panneau de l'éspace des phases contient un \textbf{SKPlot2D} pour 
dessiner et un \textbf{Oscillateur} pour mettre à jour par rapport aux valeurs de 
position et vitesse stockés dans le descriptor.
Ces valuers sont ajouté, à chaque appel de \textit{updatePanel()}, dans le
buffer du déssin de la courbe.
L'éspace des phases contient aussi un panneau qui permet de gerer le buffer de
dessin par trois boutons:

\begin{itemize}
\item \textbf{start}: abiliter le déssin de la courbe
\item \textbf{stop}: arrêter le déssin de la courbe
\item \textbf{clear}: néttoyer la courbe
\end{itemize}

\section{Visualisateurs et modificateurs des valeurs}

Pour pouvoir visualiser et modifier les valeurs on a crée trois structures
de panneaux pour le faire:

\begin{itemize}
\item \textbf{ValueVisual}: il utilise un \textbf{QLabel} et peut afficher un
valeur double
\item \textbf{Valuedit}: mouni d'un \textbf{QLineEdit} permet de modifier aussi
la valeur, il implémente donc un \textit{signal} qui est émis quand
l'utilisateur modifie la valeur par un double. C'est possibile de le
\textit{connécter} par des \textbf{QObject} éxtérieures.
\item \textbf{VectorEdit}: c'est un éxténsion du précedent, où les QLineEdit
sont déplacés en horizontal ou en vertical et un peut quand même les connécter.
\end{itemize}

\chapter{Conclusion}

Ce projet contient tout ce qui est nécéssaire pour faire des simulations en 3D.
En fait, on a dévéloppé aussi deux tests \textit{alpha} et \textit{beta} pour montrer 
ce qu'on peut faire en utilisant ces bibliothèques.
Alpha consiste dans une scène 3D et beta est un éxtension du précendent, mais il 
contient aussi un fenêtre pour modifier les valeurs et les constantes physiques
des oscillateurs.
Le code contient beaucoup d'instruments qui n'était pas demandés par la
consigne du projet, comme par éxemple la \textit{NewtonSphere} qui peut subir une force
de répulsion par l'utilisateur. Mais ces instruments seront plus utiles dans le
futur quand on aura besoin de simuler en 3D sans devoir se référer à des
bibliothéques éxterieures.
Ces trois bibliothèque, en fait, ont comme but celui de pouvoir être utilisées pour simuler
des systèmes de façon complète, avec un graphisme de base optimisé et
un'instrument tout à fait basilaire pour créer des modificateurs de valeurs.

\end{document}
